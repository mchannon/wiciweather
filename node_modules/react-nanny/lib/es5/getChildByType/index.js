"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getChildByTypeDeep = exports.getChildByType = void 0;
var React = require("react");
var utils_1 = require("./../_private/utils");
var getChildrenByType_1 = require("../getChildrenByType");
var typeOfComponent_1 = require("../typeOfComponent");
/**
 * Gets first child by specified type
 *
 * @since v1.0.0 (modified v2.0.0)
 * @template T
 * @template TC
 * @param {T} children - JSX children
 * @param {TC | TC[]} types - Types of children to match
 * @param {GetChildByTypeConfig} [config={ customTypeKey: '__TYPE', prioritized: false }] - The configuration params
 * @returns {T} - The first matching child
 * @docgen_types
 * // The configuration type for the util:
 * //   customTypeKey?: string = '__TYPE' - The custom component prop key to check the type
 * //   prioritized?: boolean = false - Whether or not the order of types is prioritized
 *
 * export type GetChildByTypeConfig = { customTypeKey?: string, prioritized?: boolean };
 * @example
 * // Finds the first occurrence of either a ToDo (custom component w/defined type as prop), a div, or a React Fragment
 * getChildByType(children, ['ToDo', 'div', 'react.fragment']);
 *
 * // Finds the first occurrence of either a MyComponent (custom component - full component passed in), a div, or a React Fragment
 * import MyComponent from './MyComponent';
 * getChildByType(children, [MyComponent, 'div', 'react.fragment']);
 *
 * // Finds the first occurrence of either a ToDo, a div, or a React Fragment with a preference for that order. If ToDo exists, it will return that first. If not, then div, etc.
 * getChildByType(children, ['ToDo', 'div', 'react.fragment'], { prioritized: true });
 * @docgen_note
 * This function will check the prop <em>{customTypeKey}</em> first and then <em>component.type</em> to match core html (JSX intrinsic) elements or component functions. To find a React Fragment, search for <em>'react.fragment'</em>.
 * @docgen_import { getChildByType, GetChildByTypeConfig }
 * @docgen_imp_note <em>GetChildByTypeConfig</em> is a TypeScript type and is only for (optional) use with TypeScript projects
 */
var getChildByType = function (children, types, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.customTypeKey, customTypeKey = _c === void 0 ? '__TYPE' : _c, _d = _b.prioritized, prioritized = _d === void 0 ? false : _d;
    var _types = utils_1.processTypes(Array.isArray(types) ? types : [types]);
    var matches = React.Children.toArray(children).filter(function (child) { return _types.indexOf(typeOfComponent_1.typeOfComponent(child, customTypeKey)) !== -1; });
    if (prioritized) {
        var _loop_1 = function (type) {
            var match = matches.find(function (x) { return typeOfComponent_1.typeOfComponent(x, customTypeKey) === type; });
            if (match)
                return { value: match };
        };
        for (var _i = 0, _types_1 = _types; _i < _types_1.length; _i++) {
            var type = _types_1[_i];
            var state_1 = _loop_1(type);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    return matches[0];
};
exports.getChildByType = getChildByType;
/**
 * Gets first child by specified type (deep search)
 *
 * @since v1.0.0 (modified v2.0.0)
 * @template T
 * @template TC
 * @param {T} children - JSX children
 * @param {TC | TC[]} types - Types of children to match
 * @param {GetChildByTypeConfig} [{ customTypeKey: '__TYPE', prioritized: false }] - The configuration params
 * @returns {T} - The first matching child
 * @docgen_types
 * // The configuration type for the util:
 * //   customTypeKey?: string = '__TYPE' - The custom component prop key to check the type
 * //   prioritized?: boolean = false - Whether or not the order of types is prioritized
 *
 * export type GetChildByTypeConfig = { customTypeKey?: string, prioritized?: boolean };
 * @example
 * // Finds the first occurrence of either a ToDo (custom component w/defined type as prop), a div, or a React Fragment
 * getChildByTypeDeep(children, ['ToDo', 'div', 'react.fragment']);
 *
 * // Finds the first occurrence of either a MyComponent (custom component - full component passed in), a div, or a React Fragment
 * import MyComponent from './MyComponent';
 * getChildByTypeDeep(children, [MyComponent, 'div', 'react.fragment']);
 *
 * // Finds the first occurrence of either a ToDo, a div, or a React Fragment with a preference for that order. If ToDo exists, it will return that first. If not, then div, etc.
 * getChildByTypeDeep(children, ['ToDo', 'div', 'react.fragment'], { prioritized: true });
 * @docgen_note
 * This function will check the prop <em>{customTypeKey}</em> first and then <em>component.type</em> to match core html (JSX intrinsic) elements or component functions. To find a React Fragment, search for <em>'react.fragment'</em>.
 * @docgen_import { getChildByTypeDeep, GetChildByTypeConfig }
 * @docgen_imp_note <em>GetChildByTypeConfig</em> is a TypeScript type and is only for (optional) use with TypeScript projects
 */
var getChildByTypeDeep = function (children, types, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.customTypeKey, customTypeKey = _c === void 0 ? '__TYPE' : _c, _d = _b.prioritized, prioritized = _d === void 0 ? false : _d;
    var _types = utils_1.processTypes(Array.isArray(types) ? types : [types]);
    var matches = getChildrenByType_1.getChildrenByTypeDeep(children, _types, { customTypeKey: customTypeKey });
    if (prioritized) {
        var _loop_2 = function (type) {
            var match = matches.find(function (x) { return typeOfComponent_1.typeOfComponent(x, customTypeKey) === type; });
            if (match)
                return { value: match };
        };
        for (var _i = 0, _types_2 = _types; _i < _types_2.length; _i++) {
            var type = _types_2[_i];
            var state_2 = _loop_2(type);
            if (typeof state_2 === "object")
                return state_2.value;
        }
    }
    return matches[0];
};
exports.getChildByTypeDeep = getChildByTypeDeep;
