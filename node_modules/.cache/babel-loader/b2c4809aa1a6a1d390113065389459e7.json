{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nimport * as React from 'react';\n/**\r\n * Gets the depth to the first descendant (or self) of each root child that match the specified predicate\r\n *\r\n * @since v2.6.0\r\n * @template T\r\n * @template TC - Type of child\r\n * @param {T} children - JSX children\r\n * @param {(child: T) => boolean} predicate - The predicate to determine if the given child is a match\r\n * @returns {IDescendantDepth<T>[]} - The oldest ancestor with the depth to the matching descendant\r\n * @docgen_types\r\n * // The item type in the returned array:\r\n * //   ancestor: T - The oldest ancestor of a matching descendant\r\n * //   depthToMatch: number - The depth to the first predicate match; 0 indicates that the oldest ancestor matches\r\n *\r\n * export interface IDescendantDepth<T=React.ReactNode>{ ancestor: T, depthToMatch: number }\r\n * @docgen_description_note\r\n * If the child does not match the predicate or have a descendant that matches, the child is not returned with the result.\r\n */\n\nexport var getDescendantDepth = function (children, predicate) {\n  var _children = React.Children.toArray(children); // recursively get the depth of the first matching child\n\n\n  var getDepth = function (children, predicate, level) {\n    var _a;\n\n    var _children = React.Children.toArray(children);\n\n    for (var _i = 0, _children_2 = _children; _i < _children_2.length; _i++) {\n      var child = _children_2[_i];\n      if (predicate(child)) return level + 1;\n\n      if ((_a = child.props) === null || _a === void 0 ? void 0 : _a.children) {\n        var result = getDepth(child.props.children, predicate, level + 1);\n        if (result > 0) return result;\n      }\n    }\n\n    return -1;\n  };\n\n  var output = [];\n\n  for (var _i = 0, _children_1 = _children; _i < _children_1.length; _i++) {\n    var child = _children_1[_i];\n    var depthToMatch = getDepth(child, predicate, -1);\n\n    if (depthToMatch >= 0) {\n      output = __spreadArray(__spreadArray([], output), [{\n        ancestor: child,\n        depthToMatch: depthToMatch\n      }]);\n    }\n  }\n\n  return output;\n};","map":{"version":3,"sources":["/Users/brandi/wiciweather/node_modules/react-nanny/lib/es6/getDescendantDepth/index.js"],"names":["__spreadArray","to","from","i","il","length","j","React","getDescendantDepth","children","predicate","_children","Children","toArray","getDepth","level","_a","_i","_children_2","child","props","result","output","_children_1","depthToMatch","ancestor"],"mappings":"AAAA,IAAIA,aAAa,GAAI,QAAQ,KAAKA,aAAd,IAAgC,UAAUC,EAAV,EAAcC,IAAd,EAAoB;AACpE,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGF,IAAI,CAACG,MAArB,EAA6BC,CAAC,GAAGL,EAAE,CAACI,MAAzC,EAAiDF,CAAC,GAAGC,EAArD,EAAyDD,CAAC,IAAIG,CAAC,EAA/D,EACIL,EAAE,CAACK,CAAD,CAAF,GAAQJ,IAAI,CAACC,CAAD,CAAZ;;AACJ,SAAOF,EAAP;AACH,CAJD;;AAKA,OAAO,KAAKM,KAAZ,MAAuB,OAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,kBAAkB,GAAG,UAAUC,QAAV,EAAoBC,SAApB,EAA+B;AAC3D,MAAIC,SAAS,GAAGJ,KAAK,CAACK,QAAN,CAAeC,OAAf,CAAuBJ,QAAvB,CAAhB,CAD2D,CAE3D;;;AACA,MAAIK,QAAQ,GAAG,UAAUL,QAAV,EAAoBC,SAApB,EAA+BK,KAA/B,EAAsC;AACjD,QAAIC,EAAJ;;AACA,QAAIL,SAAS,GAAGJ,KAAK,CAACK,QAAN,CAAeC,OAAf,CAAuBJ,QAAvB,CAAhB;;AACA,SAAK,IAAIQ,EAAE,GAAG,CAAT,EAAYC,WAAW,GAAGP,SAA/B,EAA0CM,EAAE,GAAGC,WAAW,CAACb,MAA3D,EAAmEY,EAAE,EAArE,EAAyE;AACrE,UAAIE,KAAK,GAAGD,WAAW,CAACD,EAAD,CAAvB;AACA,UAAIP,SAAS,CAACS,KAAD,CAAb,EACI,OAAOJ,KAAK,GAAG,CAAf;;AACJ,UAAI,CAACC,EAAE,GAAGG,KAAK,CAACC,KAAZ,MAAuB,IAAvB,IAA+BJ,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAACP,QAA/D,EAAyE;AACrE,YAAIY,MAAM,GAAGP,QAAQ,CAACK,KAAK,CAACC,KAAN,CAAYX,QAAb,EAAuBC,SAAvB,EAAkCK,KAAK,GAAG,CAA1C,CAArB;AACA,YAAIM,MAAM,GAAG,CAAb,EACI,OAAOA,MAAP;AACP;AACJ;;AACD,WAAO,CAAC,CAAR;AACH,GAdD;;AAeA,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIL,EAAE,GAAG,CAAT,EAAYM,WAAW,GAAGZ,SAA/B,EAA0CM,EAAE,GAAGM,WAAW,CAAClB,MAA3D,EAAmEY,EAAE,EAArE,EAAyE;AACrE,QAAIE,KAAK,GAAGI,WAAW,CAACN,EAAD,CAAvB;AACA,QAAIO,YAAY,GAAGV,QAAQ,CAACK,KAAD,EAAQT,SAAR,EAAmB,CAAC,CAApB,CAA3B;;AACA,QAAIc,YAAY,IAAI,CAApB,EAAuB;AACnBF,MAAAA,MAAM,GAAGtB,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKsB,MAAL,CAAd,EAA4B,CAAC;AAAEG,QAAAA,QAAQ,EAAEN,KAAZ;AAAmBK,QAAAA,YAAY,EAAEA;AAAjC,OAAD,CAA5B,CAAtB;AACH;AACJ;;AACD,SAAOF,MAAP;AACH,CA3BM","sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n};\r\nimport * as React from 'react';\r\n/**\r\n * Gets the depth to the first descendant (or self) of each root child that match the specified predicate\r\n *\r\n * @since v2.6.0\r\n * @template T\r\n * @template TC - Type of child\r\n * @param {T} children - JSX children\r\n * @param {(child: T) => boolean} predicate - The predicate to determine if the given child is a match\r\n * @returns {IDescendantDepth<T>[]} - The oldest ancestor with the depth to the matching descendant\r\n * @docgen_types\r\n * // The item type in the returned array:\r\n * //   ancestor: T - The oldest ancestor of a matching descendant\r\n * //   depthToMatch: number - The depth to the first predicate match; 0 indicates that the oldest ancestor matches\r\n *\r\n * export interface IDescendantDepth<T=React.ReactNode>{ ancestor: T, depthToMatch: number }\r\n * @docgen_description_note\r\n * If the child does not match the predicate or have a descendant that matches, the child is not returned with the result.\r\n */\r\nexport var getDescendantDepth = function (children, predicate) {\r\n    var _children = React.Children.toArray(children);\r\n    // recursively get the depth of the first matching child\r\n    var getDepth = function (children, predicate, level) {\r\n        var _a;\r\n        var _children = React.Children.toArray(children);\r\n        for (var _i = 0, _children_2 = _children; _i < _children_2.length; _i++) {\r\n            var child = _children_2[_i];\r\n            if (predicate(child))\r\n                return level + 1;\r\n            if ((_a = child.props) === null || _a === void 0 ? void 0 : _a.children) {\r\n                var result = getDepth(child.props.children, predicate, level + 1);\r\n                if (result > 0)\r\n                    return result;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n    var output = [];\r\n    for (var _i = 0, _children_1 = _children; _i < _children_1.length; _i++) {\r\n        var child = _children_1[_i];\r\n        var depthToMatch = getDepth(child, predicate, -1);\r\n        if (depthToMatch >= 0) {\r\n            output = __spreadArray(__spreadArray([], output), [{ ancestor: child, depthToMatch: depthToMatch }]);\r\n        }\r\n    }\r\n    return output;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}