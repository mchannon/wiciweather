{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nimport * as React from 'react';\nimport { typeOfComponent } from '../typeOfComponent';\nimport { processTypes } from '../_private/utils';\n/**\r\n * Gets the depth to the first descendant (or self) of each root child that match the specified types\r\n *\r\n * @since v2.6.0\r\n * @template T\r\n * @template TC\r\n * @param {T} children - JSX children\r\n * @param {TC | TC[]} types - Types of children to match\r\n * @param {GetDescendantDepthByTypeConfig} [config={ customTypeKey: '__TYPE' }] - The configuration params\r\n * @returns {IDescendantDepth<T>[]} - The oldest ancestor with the depth to the matching descendant\r\n * @example\r\n * // Gets depth for all descendants that are of type ToDo (custom component), div, or React Fragment\r\n * getDescendantDepthByType(children, ['ToDo', 'div', 'react.fragment']);\r\n *\r\n * // Gets depth for all descendants that are of type MyComponent (custom component - full component passed in), a div, and React Fragment\r\n * import MyComponent from './MyComponent';\r\n * getDescendantDepthByType(children, [MyComponent, 'div', 'react.fragment']);\r\n *\r\n * // Gets depth for all descendants that are of type ToDo (custom component) with a customized {customTypeKey}\r\n * getDescendantDepthByType(children, ['ToDo'], { customTypeKey: 'myTypeKey' });\r\n * @docgen_types\r\n * // The configuration type for the util:\r\n * //   customTypeKey?: string = '__TYPE' - The custom component prop key to check the type\r\n *\r\n * export type GetDescendantDepthByTypeConfig = { customTypeKey?: string };\r\n *\r\n * // The item type in the returned array:\r\n * //   ancestor: T - The oldest ancestor of a matching descendant\r\n * //   depthToMatch: number - The depth to the first predicate match; 0 indicates that the oldest ancestor matches\r\n *\r\n * export interface IDescendantDepth<T=React.ReactNode>{ ancestor: T, depthToMatch: number }\r\n * @docgen_description_note\r\n * If the child does not match any of the specified types or have a descendant that matches, the child is not returned with the result.\r\n * @docgen_import { getDescendantDepthByType, GetDescendantDepthByTypeConfig }\r\n * @docgen_imp_note <em>GetDescendantDepthByTypeConfig</em> is a TypeScript type and is only for (optional) use with TypeScript projects\r\n */\n\nexport var getDescendantDepthByType = function (children, types, _a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.customTypeKey,\n      customTypeKey = _c === void 0 ? '__TYPE' : _c;\n\n  var _children = React.Children.toArray(children);\n\n  var _types = processTypes(Array.isArray(types) ? types : [types]); // recursively get the depth of the first matching child\n\n\n  var getDepth = function (children, level) {\n    var _a;\n\n    var _children = React.Children.toArray(children);\n\n    for (var _i = 0, _children_2 = _children; _i < _children_2.length; _i++) {\n      var child = _children_2[_i];\n\n      if (_types.indexOf(typeOfComponent(child, customTypeKey)) !== -1) {\n        return level + 1;\n      }\n\n      if ((_a = child.props) === null || _a === void 0 ? void 0 : _a.children) {\n        var result = getDepth(child.props.children, level + 1);\n        if (result > 0) return result;\n      }\n    }\n\n    return -1;\n  };\n\n  var output = [];\n\n  for (var _i = 0, _children_1 = _children; _i < _children_1.length; _i++) {\n    var child = _children_1[_i];\n    var depthToMatch = getDepth(child, -1);\n\n    if (depthToMatch >= 0) {\n      output = __spreadArray(__spreadArray([], output), [{\n        ancestor: child,\n        depthToMatch: depthToMatch\n      }]);\n    }\n  }\n\n  return output;\n};","map":{"version":3,"sources":["/Users/brandi/wiciweather/node_modules/react-nanny/lib/es6/getDescendantDepthByType/index.js"],"names":["__spreadArray","to","from","i","il","length","j","React","typeOfComponent","processTypes","getDescendantDepthByType","children","types","_a","_b","_c","customTypeKey","_children","Children","toArray","_types","Array","isArray","getDepth","level","_i","_children_2","child","indexOf","props","result","output","_children_1","depthToMatch","ancestor"],"mappings":"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","sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n};\r\nimport * as React from 'react';\r\nimport { typeOfComponent } from '../typeOfComponent';\r\nimport { processTypes } from '../_private/utils';\r\n/**\r\n * Gets the depth to the first descendant (or self) of each root child that match the specified types\r\n *\r\n * @since v2.6.0\r\n * @template T\r\n * @template TC\r\n * @param {T} children - JSX children\r\n * @param {TC | TC[]} types - Types of children to match\r\n * @param {GetDescendantDepthByTypeConfig} [config={ customTypeKey: '__TYPE' }] - The configuration params\r\n * @returns {IDescendantDepth<T>[]} - The oldest ancestor with the depth to the matching descendant\r\n * @example\r\n * // Gets depth for all descendants that are of type ToDo (custom component), div, or React Fragment\r\n * getDescendantDepthByType(children, ['ToDo', 'div', 'react.fragment']);\r\n *\r\n * // Gets depth for all descendants that are of type MyComponent (custom component - full component passed in), a div, and React Fragment\r\n * import MyComponent from './MyComponent';\r\n * getDescendantDepthByType(children, [MyComponent, 'div', 'react.fragment']);\r\n *\r\n * // Gets depth for all descendants that are of type ToDo (custom component) with a customized {customTypeKey}\r\n * getDescendantDepthByType(children, ['ToDo'], { customTypeKey: 'myTypeKey' });\r\n * @docgen_types\r\n * // The configuration type for the util:\r\n * //   customTypeKey?: string = '__TYPE' - The custom component prop key to check the type\r\n *\r\n * export type GetDescendantDepthByTypeConfig = { customTypeKey?: string };\r\n *\r\n * // The item type in the returned array:\r\n * //   ancestor: T - The oldest ancestor of a matching descendant\r\n * //   depthToMatch: number - The depth to the first predicate match; 0 indicates that the oldest ancestor matches\r\n *\r\n * export interface IDescendantDepth<T=React.ReactNode>{ ancestor: T, depthToMatch: number }\r\n * @docgen_description_note\r\n * If the child does not match any of the specified types or have a descendant that matches, the child is not returned with the result.\r\n * @docgen_import { getDescendantDepthByType, GetDescendantDepthByTypeConfig }\r\n * @docgen_imp_note <em>GetDescendantDepthByTypeConfig</em> is a TypeScript type and is only for (optional) use with TypeScript projects\r\n */\r\nexport var getDescendantDepthByType = function (children, types, _a) {\r\n    var _b = _a === void 0 ? {} : _a, _c = _b.customTypeKey, customTypeKey = _c === void 0 ? '__TYPE' : _c;\r\n    var _children = React.Children.toArray(children);\r\n    var _types = processTypes(Array.isArray(types) ? types : [types]);\r\n    // recursively get the depth of the first matching child\r\n    var getDepth = function (children, level) {\r\n        var _a;\r\n        var _children = React.Children.toArray(children);\r\n        for (var _i = 0, _children_2 = _children; _i < _children_2.length; _i++) {\r\n            var child = _children_2[_i];\r\n            if (_types.indexOf(typeOfComponent(child, customTypeKey)) !== -1) {\r\n                return level + 1;\r\n            }\r\n            if ((_a = child.props) === null || _a === void 0 ? void 0 : _a.children) {\r\n                var result = getDepth(child.props.children, level + 1);\r\n                if (result > 0)\r\n                    return result;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n    var output = [];\r\n    for (var _i = 0, _children_1 = _children; _i < _children_1.length; _i++) {\r\n        var child = _children_1[_i];\r\n        var depthToMatch = getDepth(child, -1);\r\n        if (depthToMatch >= 0) {\r\n            output = __spreadArray(__spreadArray([], output), [{ ancestor: child, depthToMatch: depthToMatch }]);\r\n        }\r\n    }\r\n    return output;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}